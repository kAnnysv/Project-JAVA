package org.example.program;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import org.example.annotation.OrmColumn;
import org.example.annotation.OrmColumnId;
import org.example.annotation.OrmEntity;
import org.reflections.Reflections;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class OrmManager {
    private Set<Class<?>> setClasses = new HashSet<>();
    private HikariDataSource dataSource;


    public OrmManager() {
        this.setClasses = createSetClasses();
        this.dataSource = dataSourceCreate();
    }


    private HikariDataSource dataSourceCreate() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:postgresql://127.0.0.1:5432/chat");
        config.setUsername("postgres");
        config.setPassword("123");

        return new HikariDataSource(config);

    }

    public void createTables() {
        for (Class<?> cls : setClasses) {
            if (!cls.isAnnotationPresent(OrmEntity.class)) continue;
            String tableName = cls.getAnnotation(OrmEntity.class).table();
            String queryTable = queryCreateTable(cls, tableName);
            sqlDbUpdate(queryTable);

        }

    }


    public Set<Class<?>> createSetClasses() {
        Reflections reflections = new Reflections("org.example.model");

        return reflections.getTypesAnnotatedWith(OrmEntity.class);

    }

    private void sqlDbUpdate(String querySql) {
        try (Connection connection = dataSource.getConnection()) {
            PreparedStatement statement = connection.prepareStatement(querySql);
            statement.executeUpdate();
            System.out.println(querySql);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public String queryCreateTable(Class<?> cls, String tableName) {
        StringBuilder query = new StringBuilder();
        query.append("DROP TABLE IF EXISTS ")
                .append(tableName)
                .append("; ")
                .append("CREATE TABLE IF NOT EXISTS ")
                .append(tableName)
                .append("(");
        boolean flac = true;
        Field[] fields = cls.getDeclaredFields();
        for (Field fl : fields) {
            if (fl.isAnnotationPresent(OrmColumnId.class)) {
                if (!flac) query.append(",");
                query.append("id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY");
                flac = false;
            } else if (fl.isAnnotationPresent(OrmColumn.class)) {
                if (!flac) query.append(",");
                OrmColumn ormColumn = fl.getAnnotation(OrmColumn.class);
                String columName = ormColumn.name();
                String columType = columnTypeSql(fl.getType().getSimpleName());
                query.append(columName)
                        .append(" ")
                        .append(columType);
                flac = false;


            }
        }
        query.append(");");
        return query.toString();


    }

    private static String columnTypeSql(String typeJava) {
        String typeSql = null;
        if (typeJava.equals("String")) {
            typeSql = "VARCHAR(255)";
        } else if (typeJava.equals("Long")) {
            typeSql = "BIGINT";
        } else if (typeJava.equals("Integer")) {
            typeSql = "INT";
        } else if (typeJava.equals("Boolean")) {
            typeSql = "BOOLEAN";
        } else if (typeJava.equals("Double")) {
            typeSql = "DOUBLE";
        } else {
            throw new IllegalArgumentException("Unsupported: " + typeJava);

        }
        return typeSql;
    }

    public void save(Object entity) throws IllegalAccessException, SQLException {
        Class<?> clazz = entity.getClass();
        Field[] fields = clazz.getDeclaredFields();

        if (!clazz.isAnnotationPresent(OrmEntity.class)) return;
        StringBuilder builderQuery = new StringBuilder();
        String tableName = clazz.getAnnotation(OrmEntity.class).table();
        builderQuery.append(String.format("INSERT INTO %s (", tableName));

        List<String> columns = new ArrayList<>();
        List<String> values = new ArrayList<>();

        for (Field field : fields) {
            if (field.isAnnotationPresent(OrmColumn.class)) {
                OrmColumn column = field.getAnnotation(OrmColumn.class);
                columns.add(column.name());
                field.setAccessible(true);
                Object value = field.get(entity);
                values.add(String.format("'%s'", value));
                field.setAccessible(false);
            }
        }
        builderQuery.append(String.join(", ", columns));
        builderQuery.append(") VALUES (");
        builderQuery.append(String.join(", ", values));
        builderQuery.append(");");

        sqlDbUpdate(builderQuery.toString());


    }

    public void update(Object entity) throws IllegalAccessException {
        Class<?> clazz = entity.getClass();
        if(!clazz.isAnnotationPresent(OrmEntity.class)) return;
        OrmEntity ormEntity = clazz.getAnnotation(OrmEntity.class);
        String tableName = ormEntity.table();
        StringBuilder builderQuery = new StringBuilder();
        builderQuery.append(String.format("UPDATE %s SET ", tableName));
        List<String> upClass =new ArrayList<>();
        String idColumn = null;
        Object idValue = null;
        Field[] fields = clazz.getDeclaredFields();
        for(Field field : fields){
            if(field.isAnnotationPresent(OrmColumn.class)){
                OrmColumn ormColumn = field.getAnnotation(OrmColumn.class);
                String columnNane = ormColumn.name();
                field.setAccessible(true);
                Object value = field.get(entity);
                upClass.add(String.format("%s = '%s'", columnNane, value));
                field.setAccessible(false);
            }else if(field.isAnnotationPresent(OrmColumnId.class)){
                OrmColumnId ormColumnId = field.getAnnotation(OrmColumnId.class);
                idColumn = ormColumnId.name();
                field.setAccessible(true);
                idValue = field.get(entity);
                field.setAccessible(false);


            }

        }
        builderQuery.append(String.join(", ", upClass));
        builderQuery.append(String.format(" WHERE %s = '%s';", idColumn, idValue));
        sqlDbUpdate(builderQuery.toString());

    }

    public <T> T findById(Long id, Class<T> clazz) throws SQLException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {
        if ((!clazz.isAnnotationPresent(OrmEntity.class))) return null;
        String tableName = clazz.getAnnotation(OrmEntity.class).table();
        String query = "SELECT * FROM " + tableName + " WHERE id = ?";
        Connection connection = dataSource.getConnection();
        PreparedStatement statement = connection.prepareStatement(query);
        statement.setLong(1, id);
        ResultSet resultSet = statement.executeQuery();
        if(!resultSet.next()) return null;
        return createObjectById(resultSet, clazz);


    }

    private <T> T createObjectById(ResultSet resultSet, Class<T> cls) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, SQLException {
        T instanceCls = cls.getDeclaredConstructor().newInstance();
        for(Field field : cls.getDeclaredFields()){
            field.setAccessible(true);
            if(field.isAnnotationPresent(OrmColumnId.class)){
                field.set(instanceCls, resultSet.getLong("id"));
            } else if (field.isAnnotationPresent(OrmColumn.class)) {
                OrmColumn ormColumn = field.getAnnotation(OrmColumn.class);
                field.set(instanceCls, resultSet.getObject(ormColumn.name()));

            }
            field.setAccessible(false);
        }
        return instanceCls;
    }


}
